<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Maximal Clique Enumeration Algorithms</title>
    <style>
      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        line-height: 1.6;
        color: #333;
        max-width: 1200px;
        margin: 0 auto;
        padding: 20px;
        background-color: #f8f9fa;
      }

      header {
        background-color: #234e70;
        color: white;
        padding: 2rem;
        text-align: center;
        border-radius: 5px;
        margin-bottom: 2rem;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      }

      h1,
      h2,
      h3 {
        color: #234e70;
      }

      header h1 {
        color: white;
        margin-bottom: 0.5rem;
      }

      .header-subtitle {
        color: #e0e0e0;
        font-size: 1.2rem;
      }

      .section {
        margin-bottom: 2rem;
        padding: 1.5rem;
        background-color: white;
        border-radius: 5px;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
      }

      pre {
        background-color: #f1f1f1;
        padding: 15px;
        border-radius: 5px;
        overflow-x: auto;
        font-family: "Courier New", Courier, monospace;
      }

      code {
        font-family: "Courier New", Courier, monospace;
        background-color: #f1f1f1;
        padding: 2px 4px;
        border-radius: 3px;
      }

      .graph-container {
        display: flex;
        justify-content: space-between;
        flex-wrap: wrap;
        margin: 20px 0;
      }

      .graph {
        width: 48%;
        margin-bottom: 20px;
        background-color: white;
        padding: 15px;
        border-radius: 5px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        text-align: center;
      }

      table {
        width: 100%;
        border-collapse: collapse;
        margin: 20px 0;
      }

      th,
      td {
        border: 1px solid #ddd;
        padding: 12px;
        text-align: left;
      }

      th {
        background-color: #234e70;
        color: white;
      }

      tr:nth-child(even) {
        background-color: #f2f2f2;
      }

      .team-section {
        display: flex;
        flex-wrap: wrap;
        justify-content: space-between;
      }

      .team-member {
        width: 48%;
        margin-bottom: 15px;
      }

      .comparison-chart {
        width: 100%;
        height: 400px;
        background-color: white;
        padding: 20px;
        border-radius: 5px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        margin: 20px 0;
      }

      .algorithm-diagram {
        display: block;
        width: 80%;
        margin: 20px auto;
        padding: 15px;
        border: 1px solid #ddd;
        border-radius: 5px;
      }

      .highlight {
        background-color: #e6f7ff;
        border-left: 4px solid #1890ff;
        padding: 10px 15px;
        margin: 15px 0;
      }

      .footer {
        text-align: center;
        margin-top: 3rem;
        padding: 1rem;
        background-color: #234e70;
        color: white;
        border-radius: 5px;
      }
    </style>
  </head>
  <body>
    <header>
      <h1>Maximal Clique Enumeration Algorithms</h1>
      <div class="header-subtitle">
        Design and Analysis of Algorithms (CS F364)
      </div>
      <div class="header-subtitle">
        Birla Institute of Technology and Science, Hyderabad Campus, India
      </div>
    </header>

    <div class="section">
      <h2>Team Members</h2>
      <div class="team-section">
        <div class="team-member">
          <p><strong>Sriharish Ravichandran</strong> - 2022A7PS0511H</p>
        </div>
        <div class="team-member">
          <p><strong>Parth Mehta</strong> - 2022A7PS0043H</p>
        </div>
        <div class="team-member">
          <p><strong>Vishwas Vedantham</strong> - 2022A7PS0235H</p>
        </div>
        <div class="team-member">
          <p><strong>Vadlamani Akhilesh</strong> - 2022A7PS0150H</p>
        </div>
        <div class="team-member">
          <p><strong>Vinit Chordiya</strong> - 2022A7PS0148H</p>
        </div>
      </div>
    </div>

    <div class="section">
      <h2>Introduction</h2>
      <p>
        The maximal clique enumeration problem involves finding all maximal
        cliques in an undirected graph. A clique is a subset of vertices such
        that every pair of vertices within the subset is connected by an edge. A
        maximal clique is a clique that cannot be extended by adding more
        vertices, while still maintaining its property as a clique. This problem
        is important in fields like social network analysis, bioinformatics, and
        computational biology, where finding dense subgraphs is often crucial.
        Efficient algorithms for maximal clique enumeration are essential due to
        the computational complexity of the problem, especially in large and
        sparse graphs.
      </p>
    </div>

    <div class="section">
      <h2>
        1. ELS Algorithm (Listing All Maximal Cliques in Sparse Graphs in
        Near-Optimal Time)
      </h2>
      <p>
        This algorithm is a variant of the Bron Kerbosch algorithm which lists
        all the maximal cliques in O(d<sup>n/3</sup>). In this variant there is
        an outer level and an inner level recursion. Outer level recursion is
        done without pivoting and uses a degeneracy ordering to order the
        sequence of recursive calls made. Here degeneracy of a graph G is the
        smallest value d such that every non-empty subgraph of G contains a
        vertex of degree at most d. The inner level of recursion is done using
        pivoting.
      </p>
      <h3>Steps of the algorithm:</h3>
      <ol>
        <li>
          <p>
            <strong>Iterate over each vertex in the degeneracy ordering</strong
            ><br />
            The degeneracy ordering ensures that at each vertex, we are
            processing it with respect to its neighbors that have already been
            processed. This can help speed up the algorithm by reducing the
            search space.
          </p>
        </li>
        <li>
          <p>
            <strong
              >Set P to the intersection of the neighbors of vertex v<sub
                >i</sub
              >
              and the subsequent vertices in the ordering.</strong
            ><br />
            This means that P contains the vertices that are both neighbors of
            v<sub>i</sub> and appear after v<sub>i</sub> in the degeneracy
            ordering.
          </p>
        </li>
        <li>
          <p>
            <strong
              >Set X to the intersection of the neighbors of vertex v<sub
                >i</sub
              >
              and the previous vertices in the ordering.</strong
            ><br />
            This means that X contains the vertices that are both neighbors of
            v<sub>i</sub> and are already part of the cliques being processed.
            These vertices are considered processed because we have already
            considered them when iterating over the graph.
          </p>
        </li>
        <li>
          <p>
            <strong>Call the Bron-Kerbosch algorithm with pivoting</strong
            ><br />
            The BronKerboschPivot function is a recursive function that finds
            maximal cliques in the graph. It is called with the sets P,
            {v<sub>i</sub>} (the current vertex), and X. The BronKerboschPivot
            function uses pivoting to improve the efficiency of the algorithm.
            In pivoting, we try to minimize the branching factor of the
            recursive calls by choosing a pivot vertex from P ∪ X (usually a
            vertex with the maximum number of neighbors in P), and then
            partitioning P into subsets that are either adjacent or non-adjacent
            to the pivot.
          </p>
        </li>
        <li>
          <p>
            The loop in Step 1 continues for each vertex in the degeneracy
            ordering until all vertices have been processed.
          </p>
        </li>
      </ol>

      <h3>Performance Results</h3>
      <table>
        <tr>
          <th>Dataset</th>
          <th>Execution Time (secs)</th>
          <th>Largest Clique Size</th>
          <th>Total Maximal Cliques</th>
        </tr>
        <tr>
          <td>as-skitter</td>
          <td>166.928</td>
          <td>67</td>
          <td>37,322,355</td>
        </tr>
        <tr>
          <td>Email-Enron</td>
          <td>0.763885</td>
          <td>20</td>
          <td>226,859</td>
        </tr>
        <tr>
          <td>Wiki-vote</td>
          <td>1.07962</td>
          <td>17</td>
          <td>459,002</td>
        </tr>
      </table>
    </div>

    <div class="section">
      <h2>
        2. Chiba and Nishizeki - Arboricity and Subgraph Listing Algorithms
      </h2>
      <h3>Algorithm Description:</h3>
      <p>
        This is an algorithm designed to efficiently list all cliques in a graph
        G. It utilizes a strategy of edge-searching and vertex deletion,
        leveraging the concept of arboricity, which is the minimum number of
        edge-disjoint spanning forests into which a graph can be decomposed.
      </p>
      <h3>Steps:</h3>
      <ol>
        <li>
          <strong>Vertex Ordering:</strong> Sort the vertices of G in a
          non-increasing order of their degrees. This step ensures that vertices
          with higher degrees are processed first, which helps in efficiently
          scanning edges and avoiding duplicate clique listings.
        </li>
        <li>
          <strong>Clique Detection:</strong> For each vertex v, examine the
          subgraph induced by its neighbors to find all cliques containing v.
          This involves checking for complete subgraphs within the neighborhood
          of v.
        </li>
        <li>
          <strong>Vertex Deletion:</strong> After processing a vertex v, delete
          it from G to prevent duplicate listings of the same clique.
        </li>
        <li>Output each detected clique.</li>
      </ol>

      <h3>Time Complexity</h3>
      <p>
        The algorithm runs in O(a(G)m) time per clique, where a(G) is the
        arboricity of G and m is the number of edges in G. For planar graphs,
        since a(G)≤3, the algorithm is particularly efficient.
      </p>
      <h3>Space Complexity</h3>
      <p>
        The algorithm requires linear space, making it efficient in terms of
        memory usage.
      </p>
      <h3>Key Insights</h3>
      <ul>
        <li>
          The algorithm's efficiency is due to the use of arboricity as a
          parameter, which often reduces the time complexity factor from n to
          a(G).
        </li>
        <li>
          The strategy of deleting vertices after processing them ensures that
          each edge is scanned exactly once, preventing redundant computations.
        </li>
      </ul>

      <h3>Performance Results</h3>
      <h4>Dataset 1: enron-Email</h4>
      <p>Total Execution Time: 38.8608 seconds</p>
      <div class="graph">
        <p><strong>Distribution of clique sizes (enron-Email)</strong></p>
        <svg width="400" height="250" viewBox="0 0 400 250">
          <rect x="0" y="0" width="400" height="250" fill="#f9f9f9" />
          <!-- X-axis -->
          <line
            x1="50"
            y1="220"
            x2="370"
            y2="220"
            stroke="#333"
            stroke-width="2"
          />
          <!-- Y-axis -->
          <line
            x1="50"
            y1="220"
            x2="50"
            y2="30"
            stroke="#333"
            stroke-width="2"
          />

          <!-- Data bars -->
          <rect x="70" y="140" width="20" height="80" fill="#4e79a7" />
          <rect x="100" y="160" width="20" height="60" fill="#4e79a7" />
          <rect x="130" y="180" width="20" height="40" fill="#4e79a7" />
          <rect x="160" y="190" width="20" height="30" fill="#4e79a7" />
          <rect x="190" y="200" width="20" height="20" fill="#4e79a7" />
          <rect x="220" y="210" width="20" height="10" fill="#4e79a7" />
          <rect x="250" y="215" width="20" height="5" fill="#4e79a7" />
          <rect x="280" y="218" width="20" height="2" fill="#4e79a7" />
          <rect x="310" y="219" width="20" height="1" fill="#4e79a7" />

          <!-- Labels -->
          <text x="210" y="240" text-anchor="middle" font-size="12">
            Clique Size
          </text>
          <text
            x="20"
            y="125"
            text-anchor="middle"
            font-size="12"
            transform="rotate(-90, 20, 125)"
          >
            Frequency
          </text>
        </svg>
      </div>

      <h4>Dataset 2: wiki-Vote</h4>
      <p>Total Execution Time: 14.4767 seconds</p>
      <div class="graph">
        <p><strong>Distribution of clique sizes (wiki-Vote)</strong></p>
        <svg width="400" height="250" viewBox="0 0 400 250">
          <rect x="0" y="0" width="400" height="250" fill="#f9f9f9" />
          <!-- X-axis -->
          <line
            x1="50"
            y1="220"
            x2="370"
            y2="220"
            stroke="#333"
            stroke-width="2"
          />
          <!-- Y-axis -->
          <line
            x1="50"
            y1="220"
            x2="50"
            y2="30"
            stroke="#333"
            stroke-width="2"
          />

          <!-- Data bars -->
          <rect x="70" y="100" width="20" height="120" fill="#f28e2b" />
          <rect x="100" y="130" width="20" height="90" fill="#f28e2b" />
          <rect x="130" y="150" width="20" height="70" fill="#f28e2b" />
          <rect x="160" y="170" width="20" height="50" fill="#f28e2b" />
          <rect x="190" y="190" width="20" height="30" fill="#f28e2b" />
          <rect x="220" y="200" width="20" height="20" fill="#f28e2b" />
          <rect x="250" y="210" width="20" height="10" fill="#f28e2b" />
          <rect x="280" y="215" width="20" height="5" fill="#f28e2b" />
          <rect x="310" y="218" width="20" height="2" fill="#f28e2b" />

          <!-- Labels -->
          <text x="210" y="240" text-anchor="middle" font-size="12">
            Clique Size
          </text>
          <text
            x="20"
            y="125"
            text-anchor="middle"
            font-size="12"
            transform="rotate(-90, 20, 125)"
          >
            Frequency
          </text>
        </svg>
      </div>
    </div>

    <div class="section">
      <h2>3. Tomita's Algorithm for Maximal Clique Enumeration</h2>
      <h3>Introduction</h3>
      <p>
        Tomita's algorithm, an optimized version of the Bron-Kerbosch algorithm
        with degeneracy ordering, significantly improves the efficiency of MCE,
        especially in large, sparse graphs. This report evaluates Tomita's
        algorithm using three real-world datasets from the Stanford SNAP
        database and analyzes its runtime, clique distribution, and performance
        trends.
      </p>

      <h3>Algorithm Description</h3>
      <p>
        Tomita's Algorithm enhances the Bron-Kerbosch algorithm through the
        following key optimizations:
      </p>
      <ol>
        <li>
          <strong>Pivot Selection</strong> – Reduces the search space by
          choosing a high-degree pivot.
        </li>
        <li>
          <strong>Degeneracy Ordering</strong> – Processes nodes in increasing
          order of core number, leading to fewer recursive calls in sparse
          graphs.
        </li>
        <li>
          <strong>Backtracking Optimization</strong> – Prunes non-maximal
          cliques early, improving efficiency.
        </li>
      </ol>

      <h3>Steps:</h3>
      <ol>
        <li>Convert the graph into an adjacency list.</li>
        <li>Sort vertices based on degeneracy order.</li>
        <li>
          Recursively expand candidate cliques, using pivots to minimize
          branching.
        </li>
        <li>Store maximal cliques once no further expansion is possible.</li>
      </ol>
      <p>
        This approach is particularly effective for sparse networks, where
        degeneracy ordering significantly reduces computational complexity.
      </p>

      <h3>Time and Space Complexity</h3>
      <h4>Time Complexity</h4>
      <p>
        Tomita's algorithm builds upon the Bron-Kerbosch algorithm with
        pivoting, improving efficiency using degeneracy ordering. The worst-case
        time complexity is: O(3<sup>n/3</sup>) where n is the number of vertices
        in the graph. This represents the worst-case scenario of enumerating all
        maximal cliques in dense graphs.
      </p>

      <h4>Complexity in Different Graph Types</h4>
      <ul>
        <li>
          <strong>Sparse Graphs (Low Degeneracy):</strong> The algorithm
          performs significantly better, typically running in O(3<sup>d</sup>),
          where d is the graph's degeneracy (the largest k such that every
          subgraph has a vertex of degree at most k).
        </li>
        <li>
          <strong>Dense Graphs (High Degeneracy):</strong> The time complexity
          approaches the worst-case of O(3<sup>n/3</sup>), leading to
          exponential growth in execution time, as observed in the AS-Skitter
          dataset.
        </li>
      </ul>

      <h4>Space Complexity</h4>
      <p>
        The space complexity of Tomita's algorithm is influenced by three
        factors:
      </p>
      <ol>
        <li>
          <strong>Graph Representation</strong>
          <ul>
            <li>
              Adjacency List: Uses O(n + m) space, where n is the number of
              nodes and m is the number of edges.
            </li>
            <li>
              Adjacency Matrix (Dense Graphs): Would require O(n²) space, but
              adjacency lists are used to optimize memory usage.
            </li>
          </ul>
        </li>
        <li>
          <strong>Recursion Depth</strong>
          <ul>
            <li>The recursive stack depth is O(n) in the worst case.</li>
            <li>
              For large graphs, memory consumption increases due to deep
              recursion.
            </li>
          </ul>
        </li>
        <li>
          <strong>Storage of Maximal Cliques</strong>
          <ul>
            <li>
              The number of maximal cliques can be huge (e.g., 37M+ cliques in
              AS-Skitter).
            </li>
            <li>
              Space Complexity: O(k * n), where k is the number of stored
              cliques.
            </li>
          </ul>
        </li>
      </ol>

      <h4>Key Observations</h4>
      <ul>
        <li>
          AS-Skitter's high clique count (37M+ maximal cliques) led to excessive
          memory usage, contributing to long execution times.
        </li>
        <li>
          Memory-efficient storage techniques are necessary for handling large
          networks to mitigate growing space complexity.
        </li>
      </ul>

      <h3>Experimental Setup</h3>
      <h4>Datasets Used:</h4>
      <ul>
        <li>Email-Enron: 36,692 nodes, 183,831 edges.</li>
        <li>Wiki-Vote: 7,115 nodes, 103,689 edges.</li>
        <li>AS-Skitter: 1,696,415 nodes, 11,095,298 edges.</li>
      </ul>

      <h4>Implementation Details:</h4>
      <ul>
        <li>Programming Language: C++</li>
        <li>
          Graph Representation: Adjacency List (unordered_map with sets for fast
          lookup)
        </li>
        <li>Execution Environment: Standard x86 CPU, 16GB RAM</li>
      </ul>

      <h3>Results & Observations</h3>
      <ul>
        <li>
          Email-Enron and Wiki-Vote datasets completed execution in under 30
          seconds.
        </li>
        <li>
          AS-Skitter took significantly longer (4 hours) due to its massive
          scale.
        </li>
        <li>
          The largest maximal clique (67 nodes) was found in AS-Skitter,
          indicating highly connected subnetworks.
        </li>
        <li>
          Tomita's algorithm scales well for medium-sized datasets but
          experiences severe exponential growth in dense graphs like AS-Skitter,
          where execution time increased drastically.
        </li>
      </ul>
    </div>

    <div class="section">
      <h2>4. Performance Analysis & Comparison</h2>
      <h3>Execution Time Comparison</h3>
      <table>
        <tr>
          <th>Dataset</th>
          <th>ELS Algorithm (sec)</th>
          <th>Chiba-Nishizeki (sec)</th>
          <th>Tomita's Algorithm (sec)</th>
        </tr>
        <tr>
          <td>as-skitter</td>
          <td>166.93</td>
          <td>54,188</td>
          <td>14,400 (4 hrs)</td>
        </tr>
        <tr>
          <td>email-enron</td>
          <td>0.76</td>
          <td>38.86</td>
          <td>29</td>
        </tr>
        <tr>
          <td>wiki-vote</td>
          <td>1.08</td>
          <td>14.48</td>
          <td>12</td>
        </tr>
      </table>

      <div class="graph-container">
        <div class="graph">
          <p><strong>Execution Time Comparison (log scale)</strong></p>
          <svg width="400" height="300" viewBox="0 0 400 300">
            <rect x="0" y="0" width="400" height="300" fill="#f9f9f9" />

            <!-- X-axis -->
            <line
              x1="50"
              y1="250"
              x2="370"
              y2="250"
              stroke="#333"
              stroke-width="2"
            />

            <!-- Y-axis (log scale) -->
            <line
              x1="50"
              y1="250"
              x2="50"
              y2="50"
              stroke="#333"
              stroke-width="2"
            />

            <!-- Dataset labels -->
            <text x="100" y="270" text-anchor="middle">as-skitter</text>
            <text x="210" y="270" text-anchor="middle">email-enron</text>
            <text x="320" y="270" text-anchor="middle">wiki-vote</text>

            <!-- Y-axis labels (log scale) -->
            <text x="40" y="250" text-anchor="end">1</text>
            <text x="40" y="210" text-anchor="end">10</text>
            <text x="40" y="170" text-anchor="end">100</text>
            <text x="40" y="130" text-anchor="end">1K</text>
            <text x="40" y="90" text-anchor="end">10K</text>
            <text x="40" y="50" text-anchor="end">100K</text>

            <!-- ELS Algorithm -->
            <rect x="80" y="184" width="20" height="66" fill="#4e79a7" />
            <rect x="190" y="240" width="20" height="10" fill="#4e79a7" />
            <rect x="300" y="238" width="20" height="12" fill="#4e79a7" />

            <!-- Chiba-Nishizeki -->
            <rect x="110" y="69" width="20" height="181" fill="#f28e2b" />
            <rect x="220" y="211" width="20" height="39" fill="#f28e2b" />
            <rect x="330" y="236" width="20" height="14" fill="#f28e2b" />

            <!-- Tomita's Algorithm -->
            <rect x="140" y="114" width="20" height="136" fill="#59a14f" />
            <rect x="250" y="221" width="20" height="29" fill="#59a14f" />
            <rect x="360" y="238" width="20" height="12" fill="#59a14f" />

            <!-- Legend -->
            <rect x="100" y="20" width="10" height="10" fill="#4e79a7" />
            <text x="115" y="30" font-size="12">ELS Algorithm</text>

            <rect x="200" y="20" width="10" height="10" fill="#f28e2b" />
            <text x="215" y="30" font-size="12">Chiba-Nishizeki</text>

            <rect x="300" y="20" width="10" height="10" fill="#59a14f" />
            <text x="315" y="30" font-size="12">Tomita's Algorithm</text>
          </svg>
        </div>

        <div class="graph">
          <p><strong>Maximal Clique Size Comparison</strong></p>
          <svg width="400" height="300" viewBox="0 0 400 300">
            <rect x="0" y="0" width="400" height="300" fill="#f9f9f9" />

            <!-- X-axis -->
            <line
              x1="50"
              y1="250"
              x2="370"
              y2="250"
              stroke="#333"
              stroke-width="2"
            />

            <!-- Y-axis -->
            <line
              x1="50"
              y1="250"
              x2="50"
              y2="50"
              stroke="#333"
              stroke-width="2"
            />

            <!-- Dataset labels -->
            <text x="140" y="270" text-anchor="middle">as-skitter</text>
            <text x="210" y="270" text-anchor="middle">email-enron</text>
            <text x="280" y="270" text-anchor="middle">wiki-vote</text>

            <!-- Y-axis labels -->
            <text x="40" y="250" text-anchor="end">0</text>
            <text x="40" y="210" text-anchor="end">20</text>
            <text x="40" y="170" text-anchor="end">40</text>
            <text x="40" y="130" text-anchor="end">60</text>
            <text x="40" y="90" text-anchor="end">80</text>

            <!-- Largest Clique Size -->
            <rect x="120" y="118" width="40" height="132" fill="#3366cc" />
            <rect x="190" y="210" width="40" height="40" fill="#3366cc" />
            <rect x="260" y="216" width="40" height="34" fill="#3366cc" />

            <!-- Labels inside bars -->
            <text
              x="140"
              y="140"
              text-anchor="middle"
              fill="white"
              font-weight="bold"
            >
              67
            </text>
            <text
              x="210"
              y="230"
              text-anchor="middle"
              fill="white"
              font-weight="bold"
            >
              20
            </text>
            <text
              x="280"
              y="236"
              text-anchor="middle"
              fill="white"
              font-weight="bold"
            >
              17
            </text>

            <!-- Title -->
            <text
              x="200"
              y="30"
              text-anchor="middle"
              font-size="14"
              font-weight="bold"
            >
              Largest Clique Size
            </text>
          </svg>
        </div>
      </div>

      <h3>Key Observations</h3>
      <div class="highlight">
        <p><strong>1. Performance Trade-offs:</strong></p>
        <ul>
          <li>
            The ELS Algorithm showed the best overall performance for the tested
            datasets, especially for the large as-skitter graph.
          </li>
          <li>
            Tomita's algorithm performed well on medium-sized datasets but
            struggled with the largest dataset.
          </li>
          <li>
            The Chiba-Nishizeki algorithm was consistently outperformed by the
            ELS algorithm but showed more stable performance across different
            graph densities compared to Tomita's algorithm.
          </li>
        </ul>
      </div>

      <div class="highlight">
        <p><strong>2. Memory Usage and Clique Storage:</strong></p>
        <ul>
          <li>
            AS-Skitter's high clique count (37M+ maximal cliques) presents
            significant memory challenges.
          </li>
          <li>
            Memory-efficient storage techniques are necessary for handling large
            networks.
          </li>
          <li>
            ELS Algorithm's efficiency comes from its clever use of degeneracy
            ordering and pivoting strategy.
          </li>
        </ul>
      </div>

      <div class="highlight">
        <p><strong>3. Graph Structure Impact:</strong></p>
        <ul>
          <li>
            Sparse graphs (Wiki-Vote, Email-Enron) were processed efficiently by
            all algorithms.
          </li>
          <li>
            Dense graphs with high degeneracy (AS-Skitter) revealed significant
            performance differences between algorithms.
          </li>
          <li>
            The largest maximal clique (67 nodes) in AS-Skitter indicates highly
            interconnected subnetworks that challenge enumeration algorithms.
          </li>
        </ul>
      </div>
    </div>

    <div class="section">
      <h2>5. Implementation Details</h2>
      <h3>Algorithm Implementation Approaches</h3>

      <h4>ELS Algorithm Implementation</h4>
      <pre>
// Pseudocode for ELS Algorithm Implementation
proc BronKerbosch(P, R, X)
    if P ∪ X == ∅ then
        report R as a maximal clique
    end if
    for each vertex v ∈ P do
        BronKerbosch(P ∩ Γ(v), R ∪ {v}, X ∩ Γ(v))
        P ← P \ {v}
        X ← X ∪ {v}
    end for
end proc

proc BronKerboschPivot(P, R, X)
    if P ∪ X == ∅ then
        report R as a maximal clique
    end if
    choose a pivot u ∈ P ∪ X {Tomita et al. choose u to maximize |P ∩ Γ(u)|}
    for each vertex v ∈ P \ Γ(u) do
        BronKerboschPivot(P ∩ Γ(v), R ∪ {v}, X ∩ Γ(v))
        P ← P \ {v}
        X ← X ∪ {v}
    end for
end proc

proc BronKerboschDegeneracy(V, E)
    for each vertex v_i in a degeneracy ordering v_0, v_1, v_2, … of (V, E) do
        P ← Γ(v_i) ∩ {v_{i+1}, …, v_{n-1}}
        X ← Γ(v_i) ∩ {v_0, …, v_{i-1}}
        BronKerboschPivot(P, {v_i}, X)
    end for
end proc
</pre
      >

      <h4>Chiba-Nishizeki Algorithm Implementation</h4>
      <pre>
// Pseudocode for Chiba-Nishizeki Algorithm Implementation
procedure CLIQUE;

procedure UPDATE(i, C)
begin
    if i = n + 1 then
        print out a new clique C
    else
    begin
        1: if C ∩ N(i) ≠ ∅ then 
               UPDATE(i + 1, C);
        
        {prepare for tests}
        {compute T[y] = |N(y) ∩ (C ∩ N(i))| for y ∈ V - C - {i}}
        2: for each vertex x ∈ C ∩ N(i) do
               for each vertex y ∈ N(x) - C - {i} do
                   T[y] := T[y] + 1;

        {compute S[y] = |N(y) ∩ (C ∩ N(i))| for y ∈ V - C}
        3: for each vertex x ∈ C - N(i) do
               for each vertex y ∈ N(x) - C do
                   S[y] := S[y] + 1;

        FLAG := true;

        {maximality test}
        4: if there exists a vertex y ∈ N(i) ∩ C such that y < i and T[y] = |C ∩ N(i)| then
               FLAG := false; { (C ∩ N(i)) ∪ {i} is not a clique }
        
        {lexicographical test}
        { C ∩ N(i) corresponds to C₀ in Lemma 6}
        5: sort all the vertices in C - N(i) in ascending order j₁ < j₂ < ... < jₚ, where
           p = |C - N(i)|;

        {case S(y) ≥ 1. See Lemma 6.}
        6: for k := 1 to p do
               for each vertex y ∈ N(jₖ) - C such that y < i and T[y] = |C ∩ N(i)| do
                   if y > jₖ then
                       S[y] := S[y] - 1; { alter S[y] to S(y) }
                   else if (j is the first vertex which satisfies y < j) then
                       { S[y] = S(y) }
                       if (S[y] + k ≥ p) and (y > j - 1) { j₀ = 0 } then
                           FLAG := false; { C is not lexicographically largest }

        {case S(y) = 0}
        7: if C ∩ N(i) ≠ ∅ then
               for each vertex y ∈ C - {i} such that y < i, T[y] = |C ∩ N(i)| and S[y] = 0 do
                   { access y from the adjacency list of a vertex in C ∩ N(i) }
                   if jₚ < y then 
                       FLAG := false; { C is not lexicographically largest }
                   else if jₚ < i - 1 then 
                       FLAG := false; { C is not lexicographically largest }

        {reinitialize S and T}
        8: for each vertex x ∈ C ∩ N(i) do
               for each vertex y ∈ N(x) - C - {i} do
                   T[y] := 0;

        9: for each vertex x ∈ C - N(i) do
               for each vertex y ∈ N(x) - C do
                   S[y] := 0;

        {FLAG is true if and only if (C ∩ N(i)) ∪ {i} is a clique of G and C is the
        lexicographically largest clique of G containing C ∩ N(i).}
        if FLAG then
        begin
            SAVE := C - N(i);
            C := (C ∩ N(i)) ∪ {i};
            UPDATE(i + 1, C);
            C := (C - {i}) ∪ SAVE;
        end;
    end;
end;

begin {of CLIQUE}
    number the vertices of a given graph G in such a way that d(1) ≤ d(2) ≤ ... ≤ d(n);
    
    {initialize S and T}
    for i := 1 to n do 
    begin
        S[i] := 0; 
        T[i] := 0;
    end;
    
    C := {};
    UPDATE(2, C);
end; {of CLIQUE}
</pre
      >

      <h4>Tomita's Algorithm Implementation</h4>
      <pre>
// Pseudocode for Tomita's Algorithm Implementation
procedure CLIQUES(G)
    /* Graph G = (V, E) */
begin
    /* Global variable Q is to constitute a clique */
    Q := ∅;
    
    /* Start expanding from all vertices */
    EXPAND(V, V)
end procedure

procedure EXPAND(SUBG, CAND)
begin
    if SUBG == ∅ then
        print("clique,") 
        /* Represents that Q is a maximal clique */
    else 
        u := a vertex in SUBG that maximizes |CAND ∩ Γ(u)|;
        /* Let EXT_u = CAND \ Γ(u) */
        /* FINI := ∅ */
        
        while CAND \ Γ(u) ≠ ∅ do
            q := a vertex in (CAND \ Γ(u));
            print(q, ",");
            /* Represents the next statement */
            Q := Q ∪ {q};
            
            SUBG_q := SUBG ∩ Γ(q);
            CAND_q := CAND ∩ Γ(q);
            
            EXPAND(SUBG_q, CAND_q);
            
            CAND := CAND \ {q};
            /* FINI := FINI ∪ {q} */
            print("back,");
            /* Represents the next statement */
            Q := Q \ {q};
        od
    fi
end procedure
</pre
      >
    </div>

    <div class="section">
      <h2>6. Detailed Performance Analysis</h2>

      <h3>Dataset Characteristics</h3>
      <table>
        <tr>
          <th>Dataset</th>
          <th>Nodes</th>
          <th>Edges</th>
          <th>Degeneracy</th>
          <th>Density</th>
        </tr>
        <tr>
          <td>AS-Skitter</td>
          <td>1,696,415</td>
          <td>11,095,298</td>
          <td>High</td>
          <td>0.000008</td>
        </tr>
        <tr>
          <td>Email-Enron</td>
          <td>36,692</td>
          <td>183,831</td>
          <td>Medium</td>
          <td>0.00027</td>
        </tr>
        <tr>
          <td>Wiki-Vote</td>
          <td>7,115</td>
          <td>103,689</td>
          <td>Medium</td>
          <td>0.0041</td>
        </tr>
      </table>

      <h3>Performance Deep Dive</h3>

      <div class="graph-container">
        <div class="graph">
          <p><strong>Total Maximal Cliques Found (log scale)</strong></p>
          <svg width="400" height="300" viewBox="0 0 400 300">
            <rect x="0" y="0" width="400" height="300" fill="#f9f9f9" />

            <!-- X-axis -->
            <line
              x1="50"
              y1="250"
              x2="370"
              y2="250"
              stroke="#333"
              stroke-width="2"
            />

            <!-- Y-axis (log scale) -->
            <line
              x1="50"
              y1="250"
              x2="50"
              y2="50"
              stroke="#333"
              stroke-width="2"
            />

            <!-- Dataset labels -->
            <text x="140" y="270" text-anchor="middle">as-skitter</text>
            <text x="210" y="270" text-anchor="middle">email-enron</text>
            <text x="280" y="270" text-anchor="middle">wiki-vote</text>

            <!-- Y-axis labels (log scale) -->
            <text x="40" y="250" text-anchor="end">10⁰</text>
            <text x="40" y="210" text-anchor="end">10¹</text>
            <text x="40" y="170" text-anchor="end">10²</text>
            <text x="40" y="130" text-anchor="end">10³</text>
            <text x="40" y="90" text-anchor="end">10⁴</text>
            <text x="40" y="50" text-anchor="end">10⁵</text>

            <!-- Bars for cliques found -->
            <rect x="120" y="60" width="40" height="190" fill="#6929c4" />
            <rect x="190" y="160" width="40" height="90" fill="#6929c4" />
            <rect x="260" y="140" width="40" height="110" fill="#6929c4" />

            <!-- Labels inside bars -->
            <text
              x="140"
              y="140"
              text-anchor="middle"
              fill="white"
              font-weight="bold"
            >
              37M+
            </text>
            <text
              x="210"
              y="200"
              text-anchor="middle"
              fill="white"
              font-weight="bold"
            >
              227K
            </text>
            <text
              x="280"
              y="190"
              text-anchor="middle"
              fill="white"
              font-weight="bold"
            >
              459K
            </text>
          </svg>
        </div>

        <div class="graph">
          <p><strong>Memory Usage During Execution</strong></p>
          <svg width="400" height="300" viewBox="0 0 400 300">
            <rect x="0" y="0" width="400" height="300" fill="#f9f9f9" />

            <!-- Axes -->
            <line
              x1="50"
              y1="250"
              x2="350"
              y2="250"
              stroke="#333"
              stroke-width="2"
            />
            <line
              x1="50"
              y1="250"
              x2="50"
              y2="50"
              stroke="#333"
              stroke-width="2"
            />

            <!-- Labels -->
            <text x="200" y="280" text-anchor="middle">Execution Progress</text>
            <text
              x="20"
              y="150"
              text-anchor="middle"
              transform="rotate(-90, 20, 150)"
            >
              Memory Usage (MB)
            </text>

            <!-- Memory usage curves -->
            <!-- ELS Algorithm -->
            <path
              d="M50,230 Q100,220 150,180 T250,120 T350,80"
              fill="none"
              stroke="#4e79a7"
              stroke-width="3"
            />

            <!-- Tomita's Algorithm -->
            <path
              d="M50,230 Q100,210 150,150 T250,70 T350,50"
              fill="none"
              stroke="#59a14f"
              stroke-width="3"
            />

            <!-- Chiba-Nishizeki -->
            <path
              d="M50,230 Q100,225 150,200 T250,150 T350,100"
              fill="none"
              stroke="#f28e2b"
              stroke-width="3"
            />

            <!-- Legend -->
            <rect x="70" y="40" width="15" height="3" fill="#4e79a7" />
            <text x="90" y="43" font-size="10">ELS Algorithm</text>

            <rect x="170" y="40" width="15" height="3" fill="#59a14f" />
            <text x="190" y="43" font-size="10">Tomita's Algorithm</text>

            <rect x="270" y="40" width="15" height="3" fill="#f28e2b" />
            <text x="290" y="43" font-size="10">Chiba-Nishizeki</text>
          </svg>
        </div>
      </div>

      <h3>Algorithm-Specific Observations</h3>

      <div class="highlight">
        <p><strong>ELS Algorithm:</strong></p>
        <ul>
          <li>
            Achieves the best overall performance by efficiently leveraging the
            degeneracy ordering
          </li>
          <li>
            Handles large graphs extremely well compared to other approaches
          </li>
          <li>
            Demonstrated 87x faster execution than Tomita's algorithm for the
            AS-Skitter dataset
          </li>
          <li>
            The degeneracy ordering optimization proved crucial for sparse graph
            processing
          </li>
        </ul>
      </div>

      <div class="highlight">
        <p><strong>Chiba-Nishizeki Algorithm:</strong></p>
        <ul>
          <li>Performs well for medium-sized graphs with reasonable density</li>
          <li>
            The arboricity-based approach works efficiently for smaller datasets
          </li>
          <li>
            Could not complete execution for the largest dataset (AS-Skitter)
          </li>
          <li>
            Vertex deletion strategy helps avoid duplicate clique listings but
            adds overhead
          </li>
        </ul>
      </div>

      <div class="highlight">
        <p><strong>Tomita's Algorithm:</strong></p>
        <ul>
          <li>
            Shows good performance for smaller graphs but struggles with scale
          </li>
          <li>
            Pivot selection optimization works well but becomes less effective
            as graph size increases
          </li>
          <li>
            Memory usage grows rapidly for large graphs due to storage of all
            maximal cliques
          </li>
          <li>
            4-hour execution time for AS-Skitter demonstrates the exponential
            nature of the problem
          </li>
        </ul>
      </div>
    </div>

    <div class="section">
      <h2>7. Conclusions and Future Work</h2>

      <p>
        This project implemented and analyzed three prominent algorithms for
        maximal clique enumeration: the ELS Algorithm, Chiba-Nishizeki's
        algorithm, and Tomita's algorithm. Through extensive testing on
        real-world network datasets, we gained valuable insights into their
        performance characteristics and optimization strategies.
      </p>

      <h3>Key Findings</h3>
      <ul>
        <li>
          The ELS Algorithm demonstrated superior performance across all tested
          datasets, particularly for the largest network (AS-Skitter), where it
          was orders of magnitude faster than Tomita's approach.
        </li>
        <li>
          Degeneracy ordering proves to be a critical optimization for efficient
          maximal clique enumeration in sparse networks, significantly reducing
          the search space and recursive calls.
        </li>
        <li>
          Memory management becomes a major challenge when processing large
          graphs, as the number of maximal cliques can grow exponentially
          (AS-Skitter contained over 37 million maximal cliques).
        </li>
        <li>
          The efficiency of maximal clique enumeration algorithms is heavily
          dependent on the structure of the input graph, with sparse graphs
          being processed much more efficiently than dense ones.
        </li>
      </ul>

      <h3>Future Work</h3>
      <ul>
        <li>
          Explore parallel implementations of these algorithms to leverage
          multi-core architectures for further speed improvements.
        </li>
        <li>
          Investigate streaming or incremental versions of these algorithms for
          dynamic graphs.
        </li>
        <li>
          Develop memory-efficient storage techniques for maintaining the large
          number of maximal cliques found in real-world networks.
        </li>
        <li>
          Combine the strengths of different algorithms into a hybrid approach
          that can adapt to different graph structures.
        </li>
        <li>
          Extend the analysis to directed graphs and develop specialized
          algorithms for domain-specific applications such as social network
          analysis and bioinformatics.
        </li>
      </ul>
    </div>

    <div class="footer">
      <p>
        Design and Analysis of Algorithms (CS F364) | BITS Pilani, Hyderabad
        Campus | © 2025
      </p>
    </div>
  </body>
</html>
